"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.semidiameter = semidiameter;
exports.aaturnApparentPolar = aaturnApparentPolar;
exports.moonTopocentric = moonTopocentric;
exports.moonTopocentric2 = moonTopocentric2;
exports.asteroidDiameter = asteroidDiameter;
exports.asteroid = asteroid;
exports["default"] = exports.Moon = exports.Pluto = exports.Neptune = exports.Uranus = exports.SaturnPolar = exports.SaturnEquatorial = exports.JupiterPolar = exports.JupiterEquatorial = exports.Mars = exports.VenusCloud = exports.VenusSurface = exports.Mercury = exports.Sun = void 0;

var _base = _interopRequireDefault(require("./base"));

var _parallax = _interopRequireDefault(require("./parallax"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable no-multi-spaces */

/**
 * Standard semidiameters at unit distance of 1 AU.
 * Values are scaled here to radians.
 */
var Sun = 959.63 / 3600 * Math.PI / 180;
exports.Sun = Sun;
var Mercury = 3.36 / 3600 * Math.PI / 180;
exports.Mercury = Mercury;
var VenusSurface = 8.34 / 3600 * Math.PI / 180;
exports.VenusSurface = VenusSurface;
var VenusCloud = 8.41 / 3600 * Math.PI / 180;
exports.VenusCloud = VenusCloud;
var Mars = 4.68 / 3600 * Math.PI / 180;
exports.Mars = Mars;
var JupiterEquatorial = 98.44 / 3600 * Math.PI / 180;
exports.JupiterEquatorial = JupiterEquatorial;
var JupiterPolar = 92.06 / 3600 * Math.PI / 180;
exports.JupiterPolar = JupiterPolar;
var SaturnEquatorial = 82.73 / 3600 * Math.PI / 180;
exports.SaturnEquatorial = SaturnEquatorial;
var SaturnPolar = 73.82 / 3600 * Math.PI / 180;
exports.SaturnPolar = SaturnPolar;
var Uranus = 35.02 / 3600 * Math.PI / 180;
exports.Uranus = Uranus;
var Neptune = 33.50 / 3600 * Math.PI / 180;
exports.Neptune = Neptune;
var Pluto = 2.07 / 3600 * Math.PI / 180;
exports.Pluto = Pluto;
var Moon = 358473400 / _base["default"].AU / 3600 * Math.PI / 180;
/* eslint-enable */

/**
 * Semidiameter returns semidiameter at specified distance.
 *
 * When used with S0 values provided, Δ must be observer-body distance in AU.
 * Result will then be in radians.
 */

exports.Moon = Moon;

function semidiameter(s0, Δ) {
  // (s0, Δ float64)  float64
  return s0 / Δ;
}
/**
 * SaturnApparentPolar returns apparent polar semidiameter of Saturn
 * at specified distance.
 *
 * Argument Δ must be observer-Saturn distance in AU.  Argument B is
 * Saturnicentric latitude of the observer as given by function saturnring.UB()
 * for example.
 *
 * Result is semidiameter in units of package variables SaturnPolar and
 * SaturnEquatorial, nominally radians.
 */


function aaturnApparentPolar(Δ, B) {
  // (Δ, B float64)  float64
  var k = SaturnPolar / SaturnEquatorial;
  k = 1 - k * k;
  var cB = Math.cos(B);
  return SaturnEquatorial / Δ * Math.sqrt(1 - k * cB * cB);
}
/**
 * MoonTopocentric returns observed topocentric semidiameter of the Moon.
 *
 *  Δ is distance to Moon in AU.
 *  δ is declination of Moon in radians.
 *  H is hour angle of Moon in radians.
 *  ρsφʹ, ρcφʹ are parallax constants as returned by
 *      globe.Ellipsoid.ParallaxConstants, for example.
 *
 * Result is semidiameter in radians.
 */


function moonTopocentric(Δ, δ, H, ρsφʹ, ρcφʹ) {
  // (Δ, δ, H, ρsφʹ, ρcφʹ float64)  float64
  var k = 0.272481;
  var sπ = Math.sin(_parallax["default"].Horizontal(Δ)); // q computed by (40.6, 40.7) p. 280, ch 40.0

  var _base$sincos = _base["default"].sincos(δ),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sδ = _base$sincos2[0],
      cδ = _base$sincos2[1];

  var _base$sincos3 = _base["default"].sincos(H),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      sH = _base$sincos4[0],
      cH = _base$sincos4[1];

  var A = cδ * sH;
  var B = cδ * cH - ρcφʹ * sπ;
  var C = sδ - ρsφʹ * sπ;
  var q = Math.sqrt(A * A + B * B + C * C);
  return k / q * sπ;
}
/**
 * MoonTopocentric2 returns observed topocentric semidiameter of the Moon
 * by a less rigorous method.
 *
 * Δ is distance to Moon in AU, h is altitude of the Moon above the observer's
 * horizon in radians.
 *
 * Result is semidiameter in radians.
 */


function moonTopocentric2(Δ, h) {
  // (Δ, h float64)  float64
  return Moon / Δ * (1 + Math.sin(h) * Math.sin(_parallax["default"].Horizontal(Δ)));
}
/**
 * AsteroidDiameter returns approximate diameter given absolute magnitude H
 * and albedo A.
 *
 * Result is in km.
 */


function asteroidDiameter(H, A) {
  // (H, A float64)  float64
  return Math.pow(10, 3.12 - 0.2 * H - 0.5 * Math.log10(A));
}
/**
 * Asteroid returns semidiameter of an asteroid with a given diameter
 * at given distance.
 *
 * Argument d is diameter in km, Δ is distance in AU.
 *
 * Result is semidiameter in radians.
 */


function asteroid(d, Δ) {
  // (d, Δ float64)  float64
  return 0.0013788 * d / Δ / 3600 * Math.PI / 180;
}

var _default = {
  Sun: Sun,
  Mercury: Mercury,
  VenusSurface: VenusSurface,
  VenusCloud: VenusCloud,
  Mars: Mars,
  JupiterEquatorial: JupiterEquatorial,
  JupiterPolar: JupiterPolar,
  SaturnEquatorial: SaturnEquatorial,
  SaturnPolar: SaturnPolar,
  Uranus: Uranus,
  Neptune: Neptune,
  Pluto: Pluto,
  Moon: Moon,
  semidiameter: semidiameter,
  aaturnApparentPolar: aaturnApparentPolar,
  moonTopocentric: moonTopocentric,
  moonTopocentric2: moonTopocentric2,
  asteroidDiameter: asteroidDiameter,
  asteroid: asteroid
};
exports["default"] = _default;