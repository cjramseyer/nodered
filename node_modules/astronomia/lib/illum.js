"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phaseAngle = phaseAngle;
exports.fraction = fraction;
exports.phaseAngle2 = phaseAngle2;
exports.phaseAngle3 = phaseAngle3;
exports.fractionVenus = fractionVenus;
exports.mercury = mercury;
exports.venus = venus;
exports.mars = mars;
exports.jupiter = jupiter;
exports.saturn = saturn;
exports.uranus = uranus;
exports.neptune = neptune;
exports.mercury84 = mercury84;
exports.venus84 = venus84;
exports.mars84 = mars84;
exports.jupiter84 = jupiter84;
exports.saturn84 = saturn84;
exports.uranus84 = uranus84;
exports.neptune84 = neptune84;
exports.pluto84 = pluto84;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var toDeg = _base["default"].toDeg;
var D2R = Math.PI / 180;
/**
 * PhaseAngle computes the phase angle of a planet.
 *
 * Argument r is planet's distance to Sun, Δ its distance to Earth, and R
 * the distance from Sun to Earth.  All distances in AU.
 *
 * Result in radians.
 */

function phaseAngle(r, Δ, R) {
  // (r, Δ, R float64)  float64
  return Math.acos((r * r + Δ * Δ - R * R) / (2 * r * Δ));
}
/**
 * Fraction computes the illuminated fraction of the disk of a planet.
 *
 * Argument r is planet's distance to Sun, Δ its distance to Earth, and R
 * the distance from Sun to Earth.  All distances in AU.
 */


function fraction(r, Δ, R) {
  // (r, Δ, R float64)  float64
  // (41.2) p. 283
  var s = r + Δ;
  return (s * s - R * R) / (4 * r * Δ);
}
/**
 * PhaseAngle2 computes the phase angle of a planet.
 *
 * Arguments L, B, R are heliocentric ecliptical coordinates of the planet.
 * L0, R0 are longitude and radius for Earth, Δ is distance from Earth to
 * the planet.  All distances in AU, angles in radians.
 *
 * The phase angle result is in radians.
 */


function phaseAngle2(L, B, R, L0, R0, Δ) {
  // (L, B, R, L0, R0, Δ float64)  float64
  // (41.3) p. 283
  return Math.acos((R - R0 * Math.cos(B) * Math.cos(L - L0)) / Δ);
}
/**
 * PhaseAngle3 computes the phase angle of a planet.
 *
 * Arguments L, B are heliocentric ecliptical longitude and latitude of the
 * planet.  x, y, z are cartesian coordinates of the planet, Δ is distance
 * from Earth to the planet.  All distances in AU, angles in radians.
 *
 * The phase angle result is in radians.
 */


function phaseAngle3(L, B, x, y, z, Δ) {
  // (L, B, x, y, z, Δ float64)  float64
  // (41.4) p. 283
  var _base$sincos = _base["default"].sincos(L),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sL = _base$sincos2[0],
      cL = _base$sincos2[1];

  var _base$sincos3 = _base["default"].sincos(B),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      sB = _base$sincos4[0],
      cB = _base$sincos4[1];

  return Math.acos((x * cB * cL + y * cB * sL + z * sB) / Δ);
}
/**
 * FractionVenus computes an approximation of the illumanted fraction of Venus.
 */


function fractionVenus(jde) {
  // (jde float64)  float64
  var T = _base["default"].J2000Century(jde);

  var V = (261.51 + 22518.443 * T) * D2R;
  var M = (177.53 + 35999.05 * T) * D2R;
  var N = (50.42 + 58517.811 * T) * D2R;
  var W = V + (1.91 * Math.sin(M) + 0.78 * Math.sin(N)) * D2R;
  var Δ = Math.sqrt(1.52321 + 1.44666 * Math.cos(W));
  var s = 0.72333 + Δ;
  return (s * s - 1) / 2.89332 / Δ;
}
/**
 * Mercury computes the visual magnitude of Mercury.
 * Formula by G. Müller
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function mercury(r, Δ, i) {
  // (r, Δ, i float64)  float64
  var s = toDeg(i) - 50;
  return 1.16 + 5 * Math.log10(r * Δ) + (0.02838 + 0.0001023 * s) * s;
}
/**
 * Venus computes the visual magnitude of Venus.
 * Formula by G. Müller
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function venus(r, Δ, i) {
  // (r, Δ, i float64)  float64
  var iDeg = toDeg(i);
  return -4 + 5 * Math.log10(r * Δ) + (0.01322 + 0.0000004247 * iDeg * iDeg) * iDeg;
}
/**
 * Mars computes the visual magnitude of Mars.
 * Formula by G. Müller
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function mars(r, Δ, i) {
  // (r, Δ, i float64)  float64
  return -1.3 + 5 * Math.log10(r * Δ) + 0.01486 * toDeg(i);
}
/**
 * Jupiter computes the visual magnitude of Jupiter.
 * Formula by G. Müller
 * Effect of phase not considered
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 */


function jupiter(r, Δ) {
  // (r, Δ float64)  float64
  return -8.93 + 5 * Math.log10(r * Δ);
}
/**
 * Saturn computes the visual magnitude of Saturn.
 * Formula by G. Müller
 * Sun's altitude above the plane of the ring is not considered.
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 * B is the Saturnicentric latitude of the Earth referred to the plane of
 * Saturn's ring.
 * ΔU (in radians) is the difference between the Saturnicentric longitudes
 * of the Sun and the Earth, measured in the plane of the ring.
 * You can use saturndisk.Disk() to obtain B and ΔU.
 */


function saturn(r, Δ, B, ΔU) {
  // (r, Δ, B, ΔU float64)  float64
  var s = Math.sin(Math.abs(B));
  return -8.68 + 5 * Math.log10(r * Δ) + 0.044 * Math.abs(toDeg(ΔU)) - 2.6 * s + 1.25 * s * s;
}
/**
 * Uranus computes the visual magnitude of Uranus.
 * Formula by G. Müller
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 */


function uranus(r, Δ) {
  // (r, Δ float64)  float64
  return -6.85 + 5 * Math.log10(r * Δ);
}
/**
 * Neptune computes the visual magnitude of Neptune.
 * Formulae by G. Müller
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 */


function neptune(r, Δ) {
  // (r, Δ float64)  float64
  return -7.05 + 5 * Math.log10(r * Δ);
}
/**
 * Mercury84 computes the visual magnitude of Mercury.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function mercury84(r, Δ, i) {
  // (r, Δ, i float64)  float64
  return _base["default"].horner(toDeg(i), -0.42 + 5 * Math.log10(r * Δ), 0.038, -0.000273, 0.000002);
}
/**
 * Venus84 computes the visual magnitude of Venus.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function venus84(r, Δ, i) {
  // (r, Δ, i float64)  float64
  return _base["default"].horner(toDeg(i), -4.4 + 5 * Math.log10(r * Δ), 0.0009, 0.000239, -0.00000065);
}
/**
 * Mars84 computes the visual magnitude of Mars.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function mars84(r, Δ, i) {
  // (r, Δ, i float64)  float64
  return -1.52 + 5 * Math.log10(r * Δ) + 0.016 * toDeg(i);
}
/**
 * Jupiter84 computes the visual magnitude of Jupiter.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth,
 * and i the phase angle in radians.
 */


function jupiter84(r, Δ, i) {
  // (r, Δ, i float64)  float64
  return -9.4 + 5 * Math.log10(r * Δ) + 0.005 * toDeg(i);
}
/**
 * Saturn84 computes the visual magnitude of Saturn.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 * B is the Saturnicentric latitude of the Earth referred to the plane of
 * Saturn's ring.
 * ΔU (in radians) is the difference between the Saturnicentric longitudes
 * of the Sun and the Earth, measured in the plane of the ring.
 */


function saturn84(r, Δ, B, ΔU) {
  // (r, Δ, B, ΔU float64)  float64
  var s = Math.sin(Math.abs(B));
  return -8.88 + 5 * Math.log10(r * Δ) + 0.044 * Math.abs(toDeg(ΔU)) - 2.6 * s + 1.25 * s * s;
}
/**
 * Uranus84 computes the visual magnitude of Uranus.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 */


function uranus84(r, Δ) {
  // (r, Δ float64)  float64
  return -7.19 + 5 * Math.log10(r * Δ);
}
/**
 * Neptune84 computes the visual magnitude of Neptune.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 */


function neptune84(r, Δ) {
  // (r, Δ float64)  float64
  return -6.87 + 5 * Math.log10(r * Δ);
}
/**
 * Pluto84 computes the visual magnitude of Pluto.
 * The formula is that adopted in "Astronomical Almanac" in 1984.0
 *
 * Argument r is the planet's distance from the Sun, Δ the distance from Earth.
 */


function pluto84(r, Δ) {
  // (r, Δ float64)  float64
  return -1 + 5 * Math.log10(r * Δ);
}

var _default = {
  phaseAngle: phaseAngle,
  fraction: fraction,
  phaseAngle2: phaseAngle2,
  phaseAngle3: phaseAngle3,
  fractionVenus: fractionVenus,
  mercury: mercury,
  venus: venus,
  mars: mars,
  jupiter: jupiter,
  saturn: saturn,
  uranus: uranus,
  neptune: neptune,
  mercury84: mercury84,
  venus84: venus84,
  mars84: mars84,
  jupiter84: jupiter84,
  saturn84: saturn84,
  uranus84: uranus84,
  neptune84: neptune84,
  pluto84: pluto84
};
exports["default"] = _default;