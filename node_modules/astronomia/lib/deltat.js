"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deltaT = deltaT;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

var _interpolation = _interopRequireDefault(require("./interpolation"));

var _deltat = _interopRequireDefault(require("../data/deltat"));

var _julian = require("./julian");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * deltaT returns the difference ΔT = TD - UT between Dynamical Time TD and
 * Univeral Time (GMT+12) in seconds
 *
 * Polynoms are from <http://eclipse.gsfc.nasa.gov/SEcat5/deltatpoly.html>
 * and <http://www.staff.science.uu.nl/~gent0113/deltat/deltat_old.htm>
 *
 * @param {Number} dyear - decimal year
 * @returns {Number} ΔT in seconds.
 */
function deltaT(dyear) {
  var ΔT;

  if (dyear < -500) {
    ΔT = _base["default"].horner((dyear - 1820) * 0.01, -20, 0, 32);
  } else if (dyear < 500) {
    ΔT = _base["default"].horner(dyear * 0.01, 10583.6, -1014.41, 33.78311, -5.952053, -0.1798452, 0.022174192, 0.0090316521);
  } else if (dyear < 1600) {
    ΔT = _base["default"].horner((dyear - 1000) * 0.01, 1574.2, -556.01, 71.23472, 0.319781, -0.8503463, -0.005050998, 0.0083572073);
  } else if (dyear < _deltat["default"].historic.first) {
    ΔT = _base["default"].horner(dyear - 1600, 120, -0.9808, -0.01532, 1 / 7129);
  } else if (dyear < _deltat["default"].data.first) {
    ΔT = interpolate(dyear, _deltat["default"].historic);
  } else if (dyear < _deltat["default"].data.last - 0.25) {
    // -0.25 ~= do not consider last 3 months in dataset
    ΔT = interpolateData(dyear, _deltat["default"].data);
  } else if (dyear < _deltat["default"].prediction.last) {
    ΔT = interpolate(dyear, _deltat["default"].prediction);
  } else if (dyear < 2050) {
    ΔT = _base["default"].horner((dyear - 2000) / 100, 62.92, 32.217, 55.89);
  } else if (dyear < 2150) {
    ΔT = _base["default"].horner((dyear - 1820) / 100, -205.72, 56.28, 32);
  } else {
    var u = (dyear - 1820) / 100;
    ΔT = -20 + 32 * u * u;
  }

  return ΔT;
}
/**
 * interpolation of dataset
 * @private
 * @param {Number} dyear - julian year
 * @returns {Number} ΔT in seconds.
 */


function interpolate(dyear, data) {
  var d3 = _interpolation["default"].len3ForInterpolateX(dyear, data.first, data.last, data.table);

  return d3.interpolateX(dyear);
}
/**
 * interpolation of dataset from finals2000A with is one entry per month
 * linear interpolation over whole dataset is inaccurate as points per month
 * are not equidistant. Therefore points are approximated using 2nd diff. interpolation
 * from current month using the following two points
 *
 * @private
 * @param {Number} dyear - julian year
 * @returns {Number} ΔT in seconds.
 */


function interpolateData(dyear, data) {
  var _data$firstYM = _slicedToArray(data.firstYM, 2),
      fyear = _data$firstYM[0],
      fmonth = _data$firstYM[1];

  var _monthOfYear = monthOfYear(dyear),
      year = _monthOfYear.year,
      month = _monthOfYear.month,
      first = _monthOfYear.first,
      last = _monthOfYear.last;

  var pos = 12 * (year - fyear) + (month - fmonth);
  var table = data.table.slice(pos, pos + 3);
  var d3 = new _interpolation["default"].Len3(first, last, table);
  return d3.interpolateX(dyear);
}
/**
* Get month of Year from fraction. Fraction differs at leap years.
* @private
* @param {Number} dyear - decimal year
* @return {Object} `{year: Number, month: Number, first: Number, last}`
*/


function monthOfYear(dyear) {
  if (!monthOfYear.data) {
    // memoize yearly fractions per month
    monthOfYear.data = {
      0: [],
      1: []
    };

    for (var m = 0; m <= 12; m++) {
      monthOfYear.data[0][m] = new _julian.Calendar(1999, m, 1).toYear() - 1999; // non leap year

      monthOfYear.data[1][m] = new _julian.Calendar(2000, m, 1).toYear() - 2000; // leap year
    }
  }

  var year = dyear | 0;
  var f = dyear - year;
  var d = (0, _julian.LeapYearGregorian)(year) ? 1 : 0;
  var data = monthOfYear.data[d];
  var month = 12; // TODO loop could be improved

  while (month > 0 && data[month] > f) {
    month--;
  }

  var first = year + data[month];
  var last = month < 11 ? year + data[month + 2] : year + 1 + data[(month + 2) % 12];
  return {
    year: year,
    month: month,
    first: first,
    last: last
  };
}

var _default = {
  deltaT: deltaT
};
exports["default"] = _default;