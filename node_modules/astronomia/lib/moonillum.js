"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phaseAngleEquatorial = phaseAngleEquatorial;
exports.phaseAngleEquatorial2 = phaseAngleEquatorial2;
exports.phaseAngleEcliptic = phaseAngleEcliptic;
exports.phaseAngleEcliptic2 = phaseAngleEcliptic2;
exports.phaseAngle3 = phaseAngle3;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var D2R = Math.PI / 180;
/**
 * phaseAngleEquatorial computes the phase angle of the Moon given equatorial coordinates.
 *
 * @param {base.Coord} cMoon - geocentric right ascension,  declination and distance to the Moon
 * @param {base.Coord} cSun - coordinates and distance of the Sun
 * @returns {number} phase angle of the Moon in radians
 */

function phaseAngleEquatorial(cMoon, cSun) {
  return pa(cMoon.range, cSun.range, cosEq(cMoon.ra, cMoon.dec, cSun.ra, cSun.dec));
}
/**
 * cos elongation from equatorial coordinates
 * @private
 */


function cosEq(α, δ, α0, δ0) {
  var _base$sincos = _base["default"].sincos(δ),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sδ = _base$sincos2[0],
      cδ = _base$sincos2[1];

  var _base$sincos3 = _base["default"].sincos(δ0),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      sδ0 = _base$sincos4[0],
      cδ0 = _base$sincos4[1];

  return sδ0 * sδ + cδ0 * cδ * Math.cos(α0 - α);
}
/**
 * phase angle from cos elongation and distances
 * @private
 * @param {number} Δ
 * @param {number} R
 * @param {number} cψ
 * @returns {number}
 */


function pa(Δ, R, cψ) {
  var sψ = Math.sin(Math.acos(cψ));
  var i = Math.atan(R * sψ / (Δ - R * cψ));

  if (i < 0) {
    i += Math.PI;
  }

  return i;
}
/**
 * phaseAngleEquatorial2 computes the phase angle of the Moon given equatorial coordinates.
 *
 * Less accurate than phaseAngleEquatorial.
 *
 * Arguments α, δ are geocentric right ascension and declination of the Moon;
 * α0, δ0  are coordinates of the Sun.  Angles must be in radians.
 *
 * @param {base.Coord} cMoon - eocentric right ascension and declination of the Moon
 * @param {base.Coord} cSun - coordinates of the Sun
 * @returns {number} phase angle of the Moon in radians
 */


function phaseAngleEquatorial2(cMoon, cSun) {
  return Math.acos(-cosEq(cMoon.ra, cMoon.dec, cSun.ra, cSun.dec));
}
/**
 * phaseAngleEcliptic computes the phase angle of the Moon given ecliptic coordinates.
 *
 * Distances must be in the same units as each other.
 *
 * @param {base.Coord} cMoon - geocentric longitude, latitude and distance to the Moon
 * @param {base.Coord} cSun -  longitude and distance to the Sun
 * @returns {number} phase angle of the Moon in radians
 */


function phaseAngleEcliptic(cMoon, cSun) {
  return pa(cMoon.range, cSun.range, cosEcl(cMoon.lon, cMoon.lat, cSun.lon));
}
/**
 * cos elongation from ecliptic coordinates
 * @private
 */


function cosEcl(λ, β, λ0) {
  // (λ, β, λ0 float64)  float64
  return Math.cos(β) * Math.cos(λ - λ0);
}
/**
 * phaseAngleEcliptic2 computes the phase angle of the Moon given ecliptic coordinates.
 *
 * Less accurate than phaseAngleEcliptic.
 *
 * Angles must be in radians.
 *
 * @param {base.Coord} cMoon - geocentric longitude, latitude of the Moon
 * @param {base.Coord} cSun -  longitude of the Sun
 * @returns {number} phase angle of the Moon in radians
 */


function phaseAngleEcliptic2(cMoon, cSun) {
  return Math.acos(-cosEcl(cMoon.lon, cMoon.lat, cSun.lon));
}
/**
 * phaseAngle3 computes the phase angle of the Moon given a julian day.
 *
 * Less accurate than phaseAngle functions taking coordinates.
 *
 * Result in radians.
 */


function phaseAngle3(jde) {
  // (jde float64)  float64
  var T = _base["default"].J2000Century(jde);

  var D = _base["default"].horner(T, 297.8501921 * D2R, 445267.1114034 * D2R, -0.0018819 * D2R, D2R / 545868, -D2R / 113065000);

  var m = _base["default"].horner(T, 357.5291092 * D2R, 35999.0502909 * D2R, -0.0001536 * D2R, D2R / 24490000);

  var m_ = _base["default"].horner(T, 134.9633964 * D2R, 477198.8675055 * D2R, 0.0087414 * D2R, D2R / 69699, -D2R / 14712000);

  return Math.PI - _base["default"].pmod(D, 2 * Math.PI) + -6.289 * D2R * Math.sin(m_) + 2.1 * D2R * Math.sin(m) + -1.274 * D2R * Math.sin(2 * D - m_) + -0.658 * D2R * Math.sin(2 * D) + -0.214 * D2R * Math.sin(2 * m_) + -0.11 * D2R * Math.sin(D);
}

var _default = {
  phaseAngleEquatorial: phaseAngleEquatorial,
  phaseAngleEquatorial2: phaseAngleEquatorial2,
  phaseAngleEcliptic: phaseAngleEcliptic,
  phaseAngleEcliptic2: phaseAngleEcliptic2,
  phaseAngle3: phaseAngle3
};
exports["default"] = _default;