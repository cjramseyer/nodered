"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.position = position;
exports.longitudeJ2000 = longitudeJ2000;
exports.positionJ2000 = positionJ2000;
exports.xyz = xyz;
exports.positionB1950 = positionB1950;
exports.positionEquinox = positionEquinox;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

var _nutation = _interopRequireDefault(require("./nutation"));

var _solar = _interopRequireDefault(require("./solar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Position returns rectangular coordinates referenced to the mean equinox of date.
 * @param {planetposition.Planet} earth - VSOP87Planet Earth
 * @param {Number} jde - Julian ephemeris day
 * @return {object} rectangular coordinates
 *   {Number} x
 *   {Number} y
 *   {Number} z
 */
function position(earth, jde) {
  // (e *pp.V87Planet, jde float64)  (x, y, z float64)
  // (26.1) p. 171
  var _solar$trueVSOP = _solar["default"].trueVSOP87(earth, jde),
      lon = _solar$trueVSOP.lon,
      lat = _solar$trueVSOP.lat,
      range = _solar$trueVSOP.range;

  var _base$sincos = _base["default"].sincos(_nutation["default"].meanObliquity(jde)),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sε = _base$sincos2[0],
      cε = _base$sincos2[1];

  var _base$sincos3 = _base["default"].sincos(lon),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      ss = _base$sincos4[0],
      cs = _base$sincos4[1];

  var sβ = Math.sin(lat);
  var x = range * cs;
  var y = range * (ss * cε - sβ * sε);
  var z = range * (ss * sε + sβ * cε);
  return {
    x: x,
    y: y,
    z: z
  };
}
/**
 * LongitudeJ2000 returns geometric longitude referenced to equinox J2000.
 * @param {planetposition.Planet} earth - VSOP87Planet Earth
 * @param {Number} jde - Julian ephemeris day
 * @return {Number} geometric longitude referenced to equinox J2000.
 */


function longitudeJ2000(earth, jde) {
  var lon = earth.position2000(jde).lon;
  return _base["default"].pmod(lon + Math.PI - 0.09033 / 3600 * Math.PI / 180, 2 * Math.PI);
}
/**
 * PositionJ2000 returns rectangular coordinates referenced to equinox J2000.
 * @param {planetposition.Planet} earth - VSOP87Planet Earth
 * @param {Number} jde - Julian ephemeris day
 * @return {object} rectangular coordinates
 *   {Number} x
 *   {Number} y
 *   {Number} z
 */


function positionJ2000(earth, jde) {
  var _xyz = xyz(earth, jde),
      x = _xyz.x,
      y = _xyz.y,
      z = _xyz.z; // (26.3) p. 174


  return {
    x: x + 0.00000044036 * y - 0.000000190919 * z,
    y: -0.000000479966 * x + 0.917482137087 * y - 0.397776982902 * z,
    z: 0.397776982902 * y + 0.917482137087 * z
  };
}

function xyz(earth, jde) {
  var _earth$position = earth.position2000(jde),
      lon = _earth$position.lon,
      lat = _earth$position.lat,
      range = _earth$position.range;

  var s = lon + Math.PI;
  var β = -lat;

  var _base$sincos5 = _base["default"].sincos(s),
      _base$sincos6 = _slicedToArray(_base$sincos5, 2),
      ss = _base$sincos6[0],
      cs = _base$sincos6[1];

  var _base$sincos7 = _base["default"].sincos(β),
      _base$sincos8 = _slicedToArray(_base$sincos7, 2),
      sβ = _base$sincos8[0],
      cβ = _base$sincos8[1]; // (26.2) p. 172


  var x = range * cβ * cs;
  var y = range * cβ * ss;
  var z = range * sβ;
  return {
    x: x,
    y: y,
    z: z
  };
}
/**
 * PositionB1950 returns rectangular coordinates referenced to B1950.
 *
 * Results are referenced to the mean equator and equinox of the epoch B1950
 * in the FK5 system, not FK4.
 *
 * @param {planetposition.Planet} earth - VSOP87Planet Earth
 * @param {Number} jde - Julian ephemeris day
 * @return {object} rectangular coordinates
 *   {Number} x
 *   {Number} y
 *   {Number} z
 */


function positionB1950(earth, jde) {
  // (e *pp.V87Planet, jde float64)  (x, y, z float64)
  var _xyz2 = xyz(earth, jde),
      x = _xyz2.x,
      y = _xyz2.y,
      z = _xyz2.z;

  return {
    x: 0.999925702634 * x + 0.012189716217 * y + 0.000011134016 * z,
    y: -0.011179418036 * x + 0.917413998946 * y - 0.397777041885 * z,
    z: -0.004859003787 * x + 0.397747363646 * y + 0.917482111428 * z
  };
}

var ζt = [2306.2181, 0.30188, 0.017998];
var zt = [2306.2181, 1.09468, 0.018203];
var θt = [2004.3109, -0.42665, -0.041833];
/**
 * PositionEquinox returns rectangular coordinates referenced to an arbitrary epoch.
 *
 * Position will be computed for given Julian day "jde" but referenced to mean
 * equinox "epoch" (year).
 *
 * @param {planetposition.Planet} earth - VSOP87Planet Earth
 * @param {Number} jde - Julian ephemeris day
 * @param {Number} epoch
 * @return {object} rectangular coordinates
 *   {Number} x
 *   {Number} y
 *   {Number} z
 */

function positionEquinox(earth, jde, epoch) {
  var xyz = positionJ2000(earth, jde);
  var x0 = xyz.x;
  var y0 = xyz.y;
  var z0 = xyz.z;
  var t = (epoch - 2000) * 0.01;
  var ζ = _base["default"].horner(t, ζt) * t * Math.PI / 180 / 3600;
  var z = _base["default"].horner(t, zt) * t * Math.PI / 180 / 3600;
  var θ = _base["default"].horner(t, θt) * t * Math.PI / 180 / 3600;

  var _base$sincos9 = _base["default"].sincos(ζ),
      _base$sincos10 = _slicedToArray(_base$sincos9, 2),
      sζ = _base$sincos10[0],
      cζ = _base$sincos10[1];

  var _base$sincos11 = _base["default"].sincos(z),
      _base$sincos12 = _slicedToArray(_base$sincos11, 2),
      sz = _base$sincos12[0],
      cz = _base$sincos12[1];

  var _base$sincos13 = _base["default"].sincos(θ),
      _base$sincos14 = _slicedToArray(_base$sincos13, 2),
      sθ = _base$sincos14[0],
      cθ = _base$sincos14[1];

  var xx = cζ * cz * cθ - sζ * sz;
  var xy = sζ * cz + cζ * sz * cθ;
  var xz = cζ * sθ;
  var yx = -cζ * sz - sζ * cz * cθ;
  var yy = cζ * cz - sζ * sz * cθ;
  var yz = -sζ * sθ;
  var zx = -cz * sθ;
  var zy = -sz * sθ;
  var zz = cθ;
  return {
    x: xx * x0 + yx * y0 + zx * z0,
    y: xy * x0 + yy * y0 + zy * z0,
    z: xz * x0 + yz * y0 + zz * z0
  };
}

var _default = {
  position: position,
  longitudeJ2000: longitudeJ2000,
  positionJ2000: positionJ2000,
  xyz: xyz,
  positionB1950: positionB1950,
  positionEquinox: positionEquinox
};
exports["default"] = _default;