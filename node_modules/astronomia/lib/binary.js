"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meanAnomaly = meanAnomaly;
exports.position = position;
exports.apparentEccentricity = apparentEccentricity;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var atan = Math.atan,
    atan2 = Math.atan2,
    cos = Math.cos,
    sqrt = Math.sqrt,
    tan = Math.tan;
/**
 * computes mean anomaly for the given date.
 *
 * @param {Number} year - is a decimal year specifying the date
 * @param {Number} T - is time of periastron, as a decimal year
 * @param {Number} P - is period of revolution in mean solar years
 * @returns {Number} mean anomaly in radians.
 */

function meanAnomaly(year, T, P) {
  // (year, T, P float64)  float64
  var n = 2 * Math.PI / P;
  return _base["default"].pmod(n * (year - T), 2 * Math.PI);
}
/**
 * Position computes apparent position angle and angular distance of
 * components of a binary star.
 *
 * @param {Number} a - is apparent semimajor axis in arc seconds
 * @param {Number} e - is eccentricity of the true orbit
 * @param {Number} i - is inclination relative to the line of sight
 * @param {Number} Ω - is position angle of the ascending node
 * @param {Number} ω - is longitude of periastron
 * @param {Number} E - is eccentric anomaly, computed for example with package kepler
 *  and the mean anomaly as returned by function M in this package.
 * @returns {Number[]} [θ, ρ]
 *  {Number} θ -is the apparent position angle in radians,
 *  {Number} ρ is the angular distance in arc seconds.
 */


function position(a, e, i, Ω, ω, E) {
  // (a, e, i, Ω, ω, E float64)  (θ, ρ float64)
  var r = a * (1 - e * cos(E));
  var ν = 2 * atan(sqrt((1 + e) / (1 - e)) * tan(E / 2));

  var _base$sincos = _base["default"].sincos(ν + ω),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sinνω = _base$sincos2[0],
      cosνω = _base$sincos2[1];

  var cosi = cos(i);
  var num = sinνω * cosi;
  var θ = atan2(num, cosνω) + Ω;

  if (θ < 0) {
    θ += 2 * Math.PI;
  }

  var ρ = r * sqrt(num * num + cosνω * cosνω);
  return [θ, ρ];
}
/**
 * ApparentEccentricity returns apparent eccenticity of a binary star
 * given true orbital elements.
 *
 * @param {Number} e - is eccentricity of the true orbit
 * @param {Number} i - is inclination relative to the line of sight
 * @param {Number} ω - is longitude of periastron
 * @returns {Number} apparent eccenticity of a binary star
 */


function apparentEccentricity(e, i, ω) {
  // (e, i, ω float64)  float64
  var cosi = cos(i);

  var _base$sincos3 = _base["default"].sincos(ω),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      sinω = _base$sincos4[0],
      cosω = _base$sincos4[1];

  var A = (1 - e * e * cosω * cosω) * cosi * cosi;
  var B = e * e * sinω * cosω * cosi;
  var C = 1 - e * e * sinω * sinω;
  var d = A - C;
  var sqrtD = sqrt(d * d + 4 * B * B);
  return sqrt(2 * sqrtD / (A + C + sqrtD));
}

var _default = {
  meanAnomaly: meanAnomaly,
  position: position,
  apparentEccentricity: apparentEccentricity
};
exports["default"] = _default;