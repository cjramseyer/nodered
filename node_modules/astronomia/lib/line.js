"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.time = time;
exports.angle = angle;
exports.error = error;
exports.angleError = angleError;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

var _interpolation = _interopRequireDefault(require("./interpolation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * Time computes the time at which a moving body is on a straight line (great
 * circle) between two fixed points, such as stars.
 *
 * Coordinates may be right ascensions and declinations or longitudes and
 * latitudes.  Fixed points are r1, d1, r2, d2.  Moving body is an ephemeris
 * of 5 rows, r3, d3, starting at time t1 and ending at time t5.  Time scale
 * is arbitrary.
 *
 * @throws Error
 * @param {Number} r1 - right ascension Coordinate 1
 * @param {Number} d1 - declination Coordinate 1
 * @param {Number} r2 - right ascension Coordinate 2
 * @param {Number} d2 - declination Coordinate 2
 * @param {Number} r3 - right ascension Coordinate 3
 * @param {Number} d2 - declination Coordinate 3
 * @param {Array} d3 -
 * @param {Array} t1 - time in Julian Days
 * @param {Array} t5 - time in Julian Days
 * @returns {Number} time of alignment in Julian Days
 */
function time(r1, d1, r2, d2, r3, d3, t1, t5) {
  // (r1, d1, r2, d2 float64, r3, d3 []float64, t1, t5 float64)  (float64, error)
  if (r3.length !== 5 || d3.length !== 5) {
    throw new Error('r3, d3 must be length 5');
  }

  var gc = new Array(5);
  r3.forEach(function (r3i, i) {
    // (19.1) p. 121
    gc[i] = Math.tan(d1) * Math.sin(r2 - r3i) + Math.tan(d2) * Math.sin(r3i - r1) + Math.tan(d3[i]) * Math.sin(r1 - r2);
  });
  var l5 = new _interpolation["default"].Len5(t1, t5, gc);
  return l5.zero(false);
}
/**
 * Angle returns the angle between great circles defined by three points.
 *
 * Coordinates may be right ascensions and declinations or longitudes and
 * latitudes.  If r1, d1, r2, d2 defines one line and r2, d2, r3, d3 defines
 * another, the result is the angle between the two lines.
 *
 * Algorithm by Meeus.
 */


function angle(r1, d1, r2, d2, r3, d3) {
  // (r1, d1, r2, d2, r3, d3 float64)  float64
  var _base$sincos = _base["default"].sincos(d2),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sd2 = _base$sincos2[0],
      cd2 = _base$sincos2[1];

  var _base$sincos3 = _base["default"].sincos(r2 - r1),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      sr21 = _base$sincos4[0],
      cr21 = _base$sincos4[1];

  var _base$sincos5 = _base["default"].sincos(r3 - r2),
      _base$sincos6 = _slicedToArray(_base$sincos5, 2),
      sr32 = _base$sincos6[0],
      cr32 = _base$sincos6[1];

  var C1 = Math.atan2(sr21, cd2 * Math.tan(d1) - sd2 * cr21);
  var C2 = Math.atan2(sr32, cd2 * Math.tan(d3) - sd2 * cr32);
  return C1 + C2;
}
/**
 * Error returns an error angle of three nearly co-linear points.
 *
 * For the line defined by r1, d1, r2, d2, the result is the anglular distance
 * between that line and r0, d0.
 *
 * Algorithm by Meeus.
 */


function error(r1, d1, r2, d2, r0, d0) {
  // (r1, d1, r2, d2, r0, d0 float64)  float64
  var _base$sincos7 = _base["default"].sincos(r1),
      _base$sincos8 = _slicedToArray(_base$sincos7, 2),
      sr1 = _base$sincos8[0],
      cr1 = _base$sincos8[1];

  var _base$sincos9 = _base["default"].sincos(d1),
      _base$sincos10 = _slicedToArray(_base$sincos9, 2),
      sd1 = _base$sincos10[0],
      cd1 = _base$sincos10[1];

  var _base$sincos11 = _base["default"].sincos(r2),
      _base$sincos12 = _slicedToArray(_base$sincos11, 2),
      sr2 = _base$sincos12[0],
      cr2 = _base$sincos12[1];

  var _base$sincos13 = _base["default"].sincos(d2),
      _base$sincos14 = _slicedToArray(_base$sincos13, 2),
      sd2 = _base$sincos14[0],
      cd2 = _base$sincos14[1];

  var X1 = cd1 * cr1;
  var X2 = cd2 * cr2;
  var Y1 = cd1 * sr1;
  var Y2 = cd2 * sr2;
  var Z1 = sd1;
  var Z2 = sd2;
  var A = Y1 * Z2 - Z1 * Y2;
  var B = Z1 * X2 - X1 * Z2;
  var C = X1 * Y2 - Y1 * X2;
  var m = Math.tan(r0);
  var n = Math.tan(d0) / Math.cos(r0);
  return Math.asin((A + B * m + C * n) / (Math.sqrt(A * A + B * B + C * C) * Math.sqrt(1 + m * m + n * n)));
}
/**
 * AngleError returns both an angle as in the function Angle, and an error
 * as in the function Error.
 *
 * The algorithm is by B. Pessens.
 *
 * @returns {Number[]} [ψ, ω]
 *  {Number} ψ - angle between great circles defined by three points.
 *  {Number} ω - error angle of three nearly co-linear points
 */


function angleError(r1, d1, r2, d2, r3, d3) {
  var _base$sincos15 = _base["default"].sincos(r1),
      _base$sincos16 = _slicedToArray(_base$sincos15, 2),
      sr1 = _base$sincos16[0],
      cr1 = _base$sincos16[1];

  var _base$sincos17 = _base["default"].sincos(d1),
      _base$sincos18 = _slicedToArray(_base$sincos17, 2),
      c1 = _base$sincos18[0],
      cd1 = _base$sincos18[1];

  var _base$sincos19 = _base["default"].sincos(r2),
      _base$sincos20 = _slicedToArray(_base$sincos19, 2),
      sr2 = _base$sincos20[0],
      cr2 = _base$sincos20[1];

  var _base$sincos21 = _base["default"].sincos(d2),
      _base$sincos22 = _slicedToArray(_base$sincos21, 2),
      c2 = _base$sincos22[0],
      cd2 = _base$sincos22[1];

  var _base$sincos23 = _base["default"].sincos(r3),
      _base$sincos24 = _slicedToArray(_base$sincos23, 2),
      sr3 = _base$sincos24[0],
      cr3 = _base$sincos24[1];

  var _base$sincos25 = _base["default"].sincos(d3),
      _base$sincos26 = _slicedToArray(_base$sincos25, 2),
      c3 = _base$sincos26[0],
      cd3 = _base$sincos26[1];

  var a1 = cd1 * cr1;
  var a2 = cd2 * cr2;
  var a3 = cd3 * cr3;
  var b1 = cd1 * sr1;
  var b2 = cd2 * sr2;
  var b3 = cd3 * sr3;
  var l1 = b1 * c2 - b2 * c1;
  var l2 = b2 * c3 - b3 * c2;
  var l3 = b1 * c3 - b3 * c1;
  var m1 = c1 * a2 - c2 * a1;
  var m2 = c2 * a3 - c3 * a2;
  var m3 = c1 * a3 - c3 * a1;
  var n1 = a1 * b2 - a2 * b1;
  var n2 = a2 * b3 - a3 * b2;
  var n3 = a1 * b3 - a3 * b1;
  var ψ = Math.acos((l1 * l2 + m1 * m2 + n1 * n2) / (Math.sqrt(l1 * l1 + m1 * m1 + n1 * n1) * Math.sqrt(l2 * l2 + m2 * m2 + n2 * n2)));
  var ω = Math.asin((a2 * l3 + b2 * m3 + c2 * n3) / (Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2) * Math.sqrt(l3 * l3 + m3 * m3 + n3 * n3)));
  return [ψ, ω];
}

var _default = {
  time: time,
  angle: angle,
  error: error,
  angleError: angleError
};
exports["default"] = _default;