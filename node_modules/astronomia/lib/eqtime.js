"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.e = e;
exports.eSmart = eSmart;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

var _coord = _interopRequireDefault(require("./coord"));

var _nutation = _interopRequireDefault(require("./nutation"));

var _solar = _interopRequireDefault(require("./solar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var cos = Math.cos,
    sin = Math.sin,
    tan = Math.tan;
/**
 * e computes the "equation of time" for the given JDE.
 *
 * Parameter planet must be a planetposition.Planet object for Earth obtained
 * with `new planetposition.Planet('earth')`.
 *
 * @param {Number} jde - Julian ephemeris day
 * @param {planetposition.Planet} earth - VSOP87 planet
 * @returns {Number} equation of time as an hour angle in radians.
 */

function e(jde, earth) {
  var τ = _base["default"].J2000Century(jde) * 0.1;
  var L0 = l0(τ); // code duplicated from solar.ApparentEquatorialVSOP87 so that
  // we can keep Δψ and cε

  var _solar$trueVSOP = _solar["default"].trueVSOP87(earth, jde),
      lon = _solar$trueVSOP.lon,
      lat = _solar$trueVSOP.lat,
      range = _solar$trueVSOP.range;

  var _nutation$nutation = _nutation["default"].nutation(jde),
      _nutation$nutation2 = _slicedToArray(_nutation$nutation, 2),
      Δψ = _nutation$nutation2[0],
      Δε = _nutation$nutation2[1];

  var a = -20.4898 / 3600 * Math.PI / 180 / range;
  var λ = lon + Δψ + a;
  var ε = _nutation["default"].meanObliquity(jde) + Δε;
  var eq = new _coord["default"].Ecliptic(λ, lat).toEquatorial(ε); // (28.1) p. 183

  var E = L0 - 0.0057183 * Math.PI / 180 - eq.ra + Δψ * cos(ε);
  return _base["default"].pmod(E + Math.PI, 2 * Math.PI) - Math.PI;
}
/**
 * (28.2) p. 183
 */


var l0 = function l0(τ) {
  return _base["default"].horner(τ, 280.4664567, 360007.6982779, 0.03032028, 1.0 / 49931, -1.0 / 15300, -1.0 / 2000000) * Math.PI / 180;
};
/**
 * eSmart computes the "equation of time" for the given JDE.
 *
 * Result is less accurate that e() but the function has the advantage
 * of not requiring the V87Planet object.
 *
 * @param {Number} jde - Julian ephemeris day
 * @returns {Number} equation of time as an hour angle in radians.
 */


function eSmart(jde) {
  var ε = _nutation["default"].meanObliquity(jde);

  var t = tan(ε * 0.5);
  var y = t * t;

  var T = _base["default"].J2000Century(jde);

  var L0 = l0(T * 0.1);

  var e = _solar["default"].eccentricity(T);

  var M = _solar["default"].meanAnomaly(T);

  var _base$sincos = _base["default"].sincos(2 * L0),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sin2L0 = _base$sincos2[0],
      cos2L0 = _base$sincos2[1];

  var sinM = sin(M); // (28.3) p. 185

  return y * sin2L0 - 2 * e * sinM + 4 * e * y * sinM * cos2L0 - y * y * sin2L0 * cos2L0 - 1.25 * e * e * sin(2 * M);
}

var _default = {
  e: e,
  eSmart: eSmart
};
exports["default"] = _default;