"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sep = sep;
exports.minSep = minSep;
exports.minSepRect = minSepRect;
exports.hav = hav;
exports.sepHav = sepHav;
exports.minSepHav = minSepHav;
exports.sepPauwels = sepPauwels;
exports.minSepPauwels = minSepPauwels;
exports.relativePosition = relativePosition;
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

var _interpolation = _interopRequireDefault(require("./interpolation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var abs = Math.abs,
    acos = Math.acos,
    asin = Math.asin,
    atan2 = Math.atan2,
    cos = Math.cos,
    hypot = Math.hypot,
    sin = Math.sin,
    sqrt = Math.sqrt,
    tan = Math.tan;
/**
 * `sep` returns the angular separation between two celestial bodies.
 *
 * The algorithm is numerically naïve, and while patched up a bit for
 * small separations, remains unstable for separations near π.
 *
 * @param {base.Coord} c1 - coordinate of celestial body 1
 * @param {base.Coord} c2 - coordinate of celestial body 2
 * @return {Number} angular separation between two celestial bodies
 */

function sep(c1, c2) {
  var _base$sincos = _base["default"].sincos(c1.dec),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sind1 = _base$sincos2[0],
      cosd1 = _base$sincos2[1];

  var _base$sincos3 = _base["default"].sincos(c2.dec),
      _base$sincos4 = _slicedToArray(_base$sincos3, 2),
      sind2 = _base$sincos4[0],
      cosd2 = _base$sincos4[1];

  var cd = sind1 * sind2 + cosd1 * cosd2 * cos(c1.ra - c2.ra); // (17.1) p. 109

  if (cd < _base["default"].CosSmallAngle) {
    return acos(cd);
  } else {
    var cosd = cos((c2.dec + c1.dec) / 2); // average dec of two bodies

    return hypot((c2.ra - c1.ra) * cosd, c2.dec - c1.dec); // (17.2) p. 109
  }
}
/**
 * `minSep` returns the minimum separation between two moving objects.
 *
 * The motion is represented as an ephemeris of three rows, equally spaced
 * in time.  Jd1, jd3 are julian day times of the first and last rows.
 * R1, d1, r2, d2 are coordinates at the three times.  They must each be
 * slices of length 3.0
 *
 * Result is obtained by computing separation at each of the three times
 * and interpolating a minimum.  This may be invalid for sufficiently close
 * approaches.
 *
 * @throws Error
 * @param {Number} jd1 - Julian day - time at cs1[0], cs2[0]
 * @param {Number} jd3 - Julian day - time at cs1[2], cs2[2]
 * @param {base.Coord[]} cs1 - 3 coordinates of moving object 1
 * @param {base.Coord[]} cs2 - 3 coordinates of moving object 2
 * @param {function} [fnSep] - alternative `sep` function e.g. `angle.sepPauwels`, `angle.sepHav`
 * @return {Number} angular separation between two celestial bodies
 */


function minSep(jd1, jd3, cs1, cs2, fnSep) {
  fnSep = fnSep || sep;

  if (cs1.length !== 3 || cs2.length !== 3) {
    throw _interpolation["default"].errorNot3;
  }

  var y = new Array(3);
  cs1.forEach(function (c, x) {
    y[x] = sep(cs1[x], cs2[x]);
  });
  var d3 = new _interpolation["default"].Len3(jd1, jd3, y);
  var dMin = d3.extremum()[1];
  return dMin;
}
/**
 * `minSepRect` returns the minimum separation between two moving objects.
 *
 * Like `minSep`, but using a method of rectangular coordinates that gives
 * accurate results even for close approaches.
 *
 * @throws Error
 * @param {Number} jd1 - Julian day - time at cs1[0], cs2[0]
 * @param {Number} jd3 - Julian day - time at cs1[2], cs2[2]
 * @param {base.Coord[]} cs1 - 3 coordinates of moving object 1
 * @param {base.Coord[]} cs2 - 3 coordinates of moving object 2
 * @return {Number} angular separation between two celestial bodies
 */


function minSepRect(jd1, jd3, cs1, cs2) {
  if (cs1.length !== 3 || cs2.length !== 3) {
    throw _interpolation["default"].ErrorNot3;
  }

  var uv = function uv(c1, c2) {
    var _base$sincos5 = _base["default"].sincos(c1.dec),
        _base$sincos6 = _slicedToArray(_base$sincos5, 2),
        sind1 = _base$sincos6[0],
        cosd1 = _base$sincos6[1];

    var Δr = c2.ra - c1.ra;
    var tanΔr = tan(Δr);
    var tanhΔr = tan(Δr / 2);
    var K = 1 / (1 + sind1 * sind1 * tanΔr * tanhΔr);
    var sinΔd = sin(c2.dec - c1.dec);
    var u = -K * (1 - sind1 / cosd1 * sinΔd) * cosd1 * tanΔr;
    var v = K * (sinΔd + sind1 * cosd1 * tanΔr * tanhΔr);
    return [u, v];
  };

  var us = new Array(3).fill(0);
  var vs = new Array(3).fill(0);
  cs1.forEach(function (c, x) {
    var _uv = uv(cs1[x], cs2[x]);

    var _uv2 = _slicedToArray(_uv, 2);

    us[x] = _uv2[0];
    vs[x] = _uv2[1];
  });
  var u3 = new _interpolation["default"].Len3(-1, 1, us); // if line throws then bug not caller's fault.

  var v3 = new _interpolation["default"].Len3(-1, 1, vs); // if line throws then bug not caller's fault.

  var up0 = (us[2] - us[0]) / 2;
  var vp0 = (vs[2] - vs[0]) / 2;
  var up1 = us[0] + us[2] - 2 * us[1];
  var vp1 = vs[0] + vs[2] - 2 * vs[1];
  var up = up0;
  var vp = vp0;
  var dn = -(us[1] * up + vs[1] * vp) / (up * up + vp * vp);
  var n = dn;
  var u;
  var v;

  for (var limit = 0; limit < 10; limit++) {
    u = u3.interpolateN(n);
    v = v3.interpolateN(n);

    if (abs(dn) < 1e-5) {
      return hypot(u, v); // success
    }

    var _up = up0 + n * up1;

    var _vp = vp0 + n * vp1;

    dn = -(u * _up + v * _vp) / (_up * _up + _vp * _vp);
    n += dn;
  }

  throw new Error('minSepRect: failure to converge');
}
/**
 * haversine function (17.5) p. 115
 */


function hav(a) {
  return 0.5 * (1 - Math.cos(a));
}
/**
 * `sepHav` returns the angular separation between two celestial bodies.
 *
 * The algorithm uses the haversine function and is superior to the naïve
 * algorithm of the Sep function.
 *
 * @param {base.Coord} c1 - coordinate of celestial body 1
 * @param {base.Coord} c2 - coordinate of celestial body 2
 * @return {Number} angular separation between two celestial bodies
 */


function sepHav(c1, c2) {
  // using (17.5) p. 115
  return 2 * asin(sqrt(hav(c2.dec - c1.dec) + cos(c1.dec) * cos(c2.dec) * hav(c2.ra - c1.ra)));
}
/**
 * Same as `minSep` but uses function `sepHav` to return the minimum separation
 * between two moving objects.
 */


function minSepHav(jd1, jd3, cs1, cs2) {
  return minSep(jd1, jd3, cs1, cs2, sepHav);
}
/**
 * `sepPauwels` returns the angular separation between two celestial bodies.
 *
 * The algorithm is a numerically stable form of that used in `sep`.
 *
 * @param {base.Coord} c1 - coordinate of celestial body 1
 * @param {base.Coord} c2 - coordinate of celestial body 2
 * @return {Number} angular separation between two celestial bodies
 */


function sepPauwels(c1, c2) {
  var _base$sincos7 = _base["default"].sincos(c1.dec),
      _base$sincos8 = _slicedToArray(_base$sincos7, 2),
      sind1 = _base$sincos8[0],
      cosd1 = _base$sincos8[1];

  var _base$sincos9 = _base["default"].sincos(c2.dec),
      _base$sincos10 = _slicedToArray(_base$sincos9, 2),
      sind2 = _base$sincos10[0],
      cosd2 = _base$sincos10[1];

  var cosdr = cos(c2.ra - c1.ra);
  var x = cosd1 * sind2 - sind1 * cosd2 * cosdr;
  var y = cosd2 * sin(c2.ra - c1.ra);
  var z = sind1 * sind2 + cosd1 * cosd2 * cosdr;
  return atan2(hypot(x, y), z);
}
/**
 * Same as `minSep` but uses function `sepPauwels` to return the minimum
 * separation between two moving objects.
 */


function minSepPauwels(jd1, jd3, cs1, cs2) {
  return minSep(jd1, jd3, cs1, cs2, sepPauwels);
}
/**
 * RelativePosition returns the position angle of one body with respect to
 * another.
 *
 * The position angle result `p` is measured counter-clockwise from North.
 * If negative then `p` is in the range of 90° ... 270°
 *
 * ````
 *                  North
 *                    |
 *             (p)  ..|
 *                 .  |
 *                V   |
 *    c1 x------------x c2
 *                    |
 * ````
 *
 * @param {base.Coord} c1 - coordinate of celestial body 1
 * @param {base.Coord} c2 - coordinate of celestial body 2
 * @return {Number} position angle (p)
 */


function relativePosition(c1, c2) {
  var _base$sincos11 = _base["default"].sincos(c1.ra - c2.ra),
      _base$sincos12 = _slicedToArray(_base$sincos11, 2),
      sinΔr = _base$sincos12[0],
      cosΔr = _base$sincos12[1];

  var _base$sincos13 = _base["default"].sincos(c2.dec),
      _base$sincos14 = _slicedToArray(_base$sincos13, 2),
      sind2 = _base$sincos14[0],
      cosd2 = _base$sincos14[1];

  var p = atan2(sinΔr, cosd2 * tan(c1.dec) - sind2 * cosΔr);
  return p;
}

var _default = {
  sep: sep,
  minSep: minSep,
  minSepRect: minSepRect,
  hav: hav,
  sepHav: sepHav,
  minSepHav: minSepHav,
  sepPauwels: sepPauwels,
  minSepPauwels: minSepPauwels,
  relativePosition: relativePosition
};
exports["default"] = _default;