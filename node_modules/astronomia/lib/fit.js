"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linear = linear;
exports.correlationCoefficient = correlationCoefficient;
exports.quadratic = quadratic;
exports.func3 = func3;
exports.func1 = func1;
exports["default"] = void 0;

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module fit
 */

/**
 * Fit: Chapter 4, Curve Fitting.
 */

/**
 * Linear fits a line to sample data.
 *
 * Argument p is a list of data points.  Results a and b are coefficients
 * of the best fit line y = ax + b.
 */
function linear(points) {
  // (p []struct{ X, Y float64 })  (a, b float64)
  var sx = 0;
  var sy = 0;
  var sx2 = 0;
  var sxy = 0;

  var _iterator = _createForOfIteratorHelper(points),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var p = _step.value;
      var x = p.x;
      var y = p.y;
      sx += x;
      sy += y;
      sx2 += x * x;
      sxy += x * y;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var n = points.length;
  var d = n * sx2 - sx * sx; // (4.2) p. 36

  var a = (n * sxy - sx * sy) / d;
  var b = (sy * sx2 - sx * sxy) / d;
  return [a, b];
}
/**
 * CorrelationCoefficient returns a correlation coefficient for sample data.
 */


function correlationCoefficient(points) {
  // (p []struct{ X, Y float64 })  float64
  var sx = 0;
  var sy = 0;
  var sx2 = 0;
  var sy2 = 0;
  var sxy = 0;

  var _iterator2 = _createForOfIteratorHelper(points),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var p = _step2.value;
      var x = p.x;
      var y = p.y;
      sx += x;
      sy += y;
      sx2 += x * x;
      sy2 += y * y;
      sxy += x * y;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var n = points.length; // (4.3) p. 38

  return (n * sxy - sx * sy) / (Math.sqrt(n * sx2 - sx * sx) * Math.sqrt(n * sy2 - sy * sy));
}
/**
 * Quadratic fits y = ax² + bx + c to sample data.
 *
 * Argument p is a list of data points.  Results a, b, and c are coefficients
 * of the best fit quadratic y = ax² + bx + c.
 */


function quadratic(points) {
  var P = 0;
  var Q = 0;
  var R = 0;
  var S = 0;
  var T = 0;
  var U = 0;
  var V = 0;

  var _iterator3 = _createForOfIteratorHelper(points),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var p = _step3.value;
      var x = p.x;
      var y = p.y;
      var x2 = x * x;
      P += x;
      Q += x2;
      R += x * x2;
      S += x2 * x2;
      T += y;
      U += x * y;
      V += x2 * y;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var N = points.length; // (4.5) p. 43

  var D = N * Q * S + 2 * P * Q * R - Q * Q * Q - P * P * S - N * R * R; // (4.6) p. 43

  var a = (N * Q * V + P * R * T + P * Q * U - Q * Q * T - P * P * V - N * R * U) / D;
  var b = (N * S * U + P * Q * V + Q * R * T - Q * Q * U - P * S * T - N * R * V) / D;
  var c = (Q * S * T + Q * R * U + P * R * V - Q * Q * V - P * S * U - R * R * T) / D;
  return [a, b, c];
}
/**
 * Func3 implements multiple linear regression for a linear combination
 * of three functions.
 *
 * Given sample data and three functions in x, Func3 returns coefficients
 * a, b, and c fitting y = aƒ₀(x) + bƒ₁(x) + cƒ₂(x) to sample data.
 */


function func3(points, f0, f1, f2) {
  var M = 0;
  var P = 0;
  var Q = 0;
  var R = 0;
  var S = 0;
  var T = 0;
  var U = 0;
  var V = 0;
  var W = 0;

  var _iterator4 = _createForOfIteratorHelper(points),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var p = _step4.value;
      var x = p.x;
      var y = p.y;
      var y0 = f0(x);
      var y1 = f1(x);
      var y2 = f2(x);
      M += y0 * y0;
      P += y0 * y1;
      Q += y0 * y2;
      R += y1 * y1;
      S += y1 * y2;
      T += y2 * y2;
      U += y * y0;
      V += y * y1;
      W += y * y2;
    } // (4.7) p. 44

  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  var D = M * R * T + 2 * P * Q * S - M * S * S - R * Q * Q - T * P * P;
  var a = (U * (R * T - S * S) + V * (Q * S - P * T) + W * (P * S - Q * R)) / D;
  var b = (U * (S * Q - P * T) + V * (M * T - Q * Q) + W * (P * Q - M * S)) / D;
  var c = (U * (P * S - R * Q) + V * (P * Q - M * S) + W * (M * R - P * P)) / D;
  return [a, b, c];
}
/**
 * Func1 fits a linear multiple of a function to sample data.
 *
 * Given sample data and a function in x, Func1 returns coefficient
 * a fitting y = aƒ(x).
 */


function func1(points, f) {
  var syf = 0;
  var sf2 = 0; // (4.8) p. 45

  var _iterator5 = _createForOfIteratorHelper(points),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var p = _step5.value;
      var fx = f(p.x);
      var y = p.y;
      syf += y * fx;
      sf2 += fx * fx;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return syf / sf2;
}

var _default = {
  linear: linear,
  correlationCoefficient: correlationCoefficient,
  quadratic: quadratic,
  func3: func3,
  func1: func1
};
exports["default"] = _default;